using std::IO
using std::Web
using std::Process
using std::File
using std::System

# --- Robust Parser (Using ASCII 32 for Space) ---
fn parse_path:
    @args req
    set i: 0
    set length: len $req
    set start: 0
    set _end: 0
    set spaces_found: 0

    while $i < $length:
        set char: $req{$i}
        if $char == 32:
            if $spaces_found == 0:
                start: $i + 1
                spaces_found: 1
            else:
                if $spaces_found == 1:
                    _end: $i
                    spaces_found: 2
                end
            end
        end
        i: $i + 1
    end

    if $spaces_found < 2:
        return "/"
    end

    set path_len: $_end - $start
    return substring($req, $start, $path_len)
end

# --- Request Handler (Runs in Child Process) ---
fn handle_client:
    @args client
    
    # 1. Read Request
    set req: Web.recieve $client, 4096
    
    # Chrome/Browsers send empty "Keep-Alive" checks; ignore them safely
    if len($req) == 0:
        Web.close $client
        return 0
    end

    # 2. Parse
    set path: parse_path $req
    set pid: Process.id(0)
    
    # Log to console (safe because print is now polymorphic)
    IO.println "[Child PID: " << str($pid) << "] Request: " << $path

    # 3. Router
    set status: "404 Not Found"
    set body: "<h1>404 Not Found</h1>"
    set content_type: "text/html"

    if $path == "/":
        status: "200 OK"
        body: "<h1>Newton Fork Server</h1><p>Served by Process ID: " << str($pid) << "</p>"
    end

    if $path == "/api/status":
        status: "200 OK"
        content_type: "application/json"
        body: "{ 'status': 'running', 'pid': " << str($pid) << " }"
    end

    # 4. File Serving
    # Try to read local file if path matches (e.g., /index.html)
    if $path == "/index.html":
        set file_data: File.readEntireFile "index.html"
        if len($file_data) > 0:
            status: "200 OK"
            body: $file_data
        end
    end

    # 5. Construct Response
    set content_len: len($body)
    set headers: "HTTP/1.1 " << $status << "\r\n"
    headers: $headers << "Content-Type: " << $content_type << "\r\n"
    headers: $headers << "Content-Length: " << str($content_len) << "\r\n"
    headers: $headers << "Connection: close\r\n\r\n"

    set full_response: $headers << $body

    # 6. Send & Exit
    Web.send $client, $full_response
    Web.close $client
end

# --- Main Server Loop ---
fn main:
    IO.println "--- Newton Forking HTTPD ---"
    IO.println "Parent PID: " << str(Process.id(0))
    
    set server: Web.new $Web.socket
    Web.bind $server, 8080
    Web.listen $server
    IO.println "Listening on 0.0.0.0:8080..."

    while 1 == 1:
        # 1. Accept Connection (Blocking)
        set client: Web.accept $server
        
        # 2. Fork Process
        # Returns 0 to Child, ChildPID to Parent
        set pid: Process.fork()

        if $pid == 0:
            # --- CHILD PROCESS ---
            Web.close $server   ; Child doesn't need listener
            handle_client $client
            Process.exit 0      ; Die after handling (prevents zombies running main loop)
        else:
            # --- PARENT PROCESS ---
            Web.close $client   ; Parent doesn't need connection (Child has a copy)
            # Parent loops back immediately to accept next connection
        end
    end
end
